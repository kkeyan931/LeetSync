class DSU {
public:
    vector<int> parent, size;

    DSU(int n) {
        parent.resize(n);
        size.resize(n, 1);
        for (int i = 0; i < n; ++i)
            parent[i] = i;
    }

    int findParent(int node) {
        if (parent[node] == node)
            return node;
        return parent[node] = findParent(parent[node]);
    }

    void unionBySize(int u, int v) {
        int pu = findParent(u);
        int pv = findParent(v);
        if (pu == pv)
            return;
        if (size[pu] < size[pv]) {
            parent[pu] = pv;
            size[pv] += size[pu];
        } else {
            parent[pv] = pu;
            size[pu] += size[pv];
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        DSU dsu(n);

        // Step 1: Build components
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j]) {
                    dsu.unionBySize(i, j);
                }
            }
        }

        // Step 2: Count number of infected nodes per component
        unordered_map<int, int> infectedCount;
        for (int node : initial) {
            int root = dsu.findParent(node);
            infectedCount[root]++;
        }

        // Step 3: Find best node to remove
        int result = -1;
        int maxSaved = -1;
        sort(initial.begin(), initial.end()); // for smallest index on tie

        for (int node : initial) {
            int root = dsu.findParent(node);
            // only one infection in this component
            if (infectedCount[root] == 1) {
                int saved = dsu.size[root];
                if (saved > maxSaved) {
                    maxSaved = saved;
                    result = node;
                }
            }
        }

        // If no node found that limits the spread
        if (result == -1) {
            result = *min_element(initial.begin(), initial.end());
        }

        return result;
    }
};
